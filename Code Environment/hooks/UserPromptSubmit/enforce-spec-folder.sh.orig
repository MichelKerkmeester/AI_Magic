#!/bin/bash

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SPEC FOLDER ENFORCEMENT HOOK
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# UserPromptSubmit hook that blocks (or warns) when a conversation
# attempts to modify files without the required spec documentation.
#
# Features
#   â€¢ Detects implementation intent based on the prompt
#   â€¢ Supports configurable enforcement modes (warning, soft, hard)
#   â€¢ Validates spec folder existence and template structure
#   â€¢ Honors configurable exception patterns for trivial edits
#   â€¢ Logs every decision to spec-enforcement.log for auditing
#   â€¢ Records execution time in performance.log (<100ms target)
#   â€¢ Uses .claude/.spec-active marker for mid-conversation detection
#
# State Marker Usage
#   â€¢ Marker file: .claude/.spec-active (contains active spec path)
#   â€¢ Create marker: When starting work in a spec folder
#     Example: echo "specs/095-feature-name" > .claude/.spec-active
#   â€¢ Cleanup marker: When conversation ends or switching specs
#     Example: rm -f .claude/.spec-active
#   â€¢ Auto-cleanup: Stale markers (pointing to non-existent folders) are removed automatically
#
# PERFORMANCE TARGET: <100ms (state checks, file validation)
# COMPATIBILITY: Bash 3.2+ (macOS and Linux compatible)
#
# EXECUTION ORDER: UserPromptSubmit hook (runs BEFORE user prompt processing)
#   1. UserPromptSubmit hooks run FIRST (before processing user input)
#   2. PreToolUse hooks run SECOND (before tool execution, validation)
#   3. PostToolUse hooks run LAST (after tool completion, verification)
#   This hook: Ensures spec folder exists for file modification intents
#
# EXIT CODE CONVENTION:
#   0 = Allow (hook passed, continue execution)
#   1 = Block (hook failed, stop execution with warning)
#   2 = Error (reserved for critical failures)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" 2>/dev/null && pwd)"
HOOKS_DIR="$(cd "$SCRIPT_DIR/.." 2>/dev/null && pwd)"
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || (cd "$SCRIPT_DIR/../.." && pwd))
CONFIG_FILE="$PROJECT_ROOT/.claude/configs/skill-rules.json"
LOG_DIR="$HOOKS_DIR/logs"
LOG_FILE="$LOG_DIR/$(basename "$0" .sh).log"
PERF_LOG="$LOG_DIR/performance.log"
SPECS_DIR="$PROJECT_ROOT/specs"
DOC_GUIDE="$PROJECT_ROOT/.claude/knowledge/conversation_documentation.md"

mkdir -p "$LOG_DIR"

source "$SCRIPT_DIR/../lib/output-helpers.sh" || exit 0
source "$SCRIPT_DIR/../lib/shared-state.sh" 2>/dev/null || true

# Source template validation library (if available)
if [ -f "$SCRIPT_DIR/../lib/template-validation.sh" ]; then
  source "$SCRIPT_DIR/../lib/template-validation.sh"
  VALIDATION_LIB_LOADED=true
else
  VALIDATION_LIB_LOADED=false
fi

START_TIME=$(date +%s%N)

check_dependency "jq" "brew install jq (macOS) or apt install jq (Linux)" || exit 0

INPUT=$(cat)
PROMPT=$(echo "$INPUT" | jq -r '.prompt // empty' 2>/dev/null)
if [ -z "$PROMPT" ]; then
  exit 0
fi
PROMPT_LOWER=$(echo "$PROMPT" | tr '[:upper:]' '[:lower:]')
PROMPT_SNIPPET="${PROMPT:0:200}"

log_event() {
  local status="$1"
  local detail="$2"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  {
    echo "$SEPARATOR"
    echo "[$timestamp] STATUS: $status"
    echo "Prompt: $PROMPT_SNIPPET"
    [ -n "$detail" ] && echo "Detail: $detail"
  } >> "$LOG_FILE"
}

MODIFICATION_KEYWORDS=(
  "add" "adjust" "apply" "build" "change" "create" "delete" "edit" "enhance" "fix"
  "implement" "improve" "modify" "optimize" "patch" "refactor" "remove" "replace"
  "revamp" "rewrite" "ship" "update" "write"
)

DETECTED_INTENT=""

detect_modification_intent() {
  # Treat "can you/could you/would you" requests that clearly ask to
  # implement or change something as modification intent, not pure questions
  if echo "$PROMPT_LOWER" | grep -qiE "^(can you|could you|would you).*(implement|add|fix|build|refactor|update|change|create|modify)"; then
    DETECTED_INTENT="question-implement"
    return 0
  fi

  # First check if this is a question (no modification intent)
  # Question patterns at start of prompt
  if echo "$PROMPT_LOWER" | grep -qE "^(what|how|why|when|where|who|which|can you|could you|would you|should|do you|does|is|are|show me|explain|tell me|help me understand)"; then
    return 1  # No modification intent
  fi

  # Check for question words + review/explain (read-only intent)
  if echo "$PROMPT_LOWER" | grep -qE "(explain|review|show|describe|tell).*(what|how|why|code|flow|work)"; then
    return 1  # No modification intent
  fi

  for keyword in "${MODIFICATION_KEYWORDS[@]}"; do
    if [[ "$PROMPT_LOWER" == *"$keyword"* ]] || [[ "$PROMPT_LOWER" == *"$keyword "* ]]; then
      DETECTED_INTENT="$keyword"
      return 0
    fi
  done

  if echo "$PROMPT_LOWER" | grep -qE "let['']?s (code|start|implement|build)"; then
    DETECTED_INTENT="collaborative-build"
    return 0
  fi

  return 1
}

ALLOWED_EXCEPTION_PATTERNS=()
ALLOWED_EXCEPTION_REASON=""
MAX_EXCEPTION_LOC=0
SINGLE_FILE_ONLY=false
ENFORCEMENT_MODE="hard-block"
VALIDATION_LEVEL="moderate"
CHECK_SPEC_FOLDER=true
CHECK_TEMPLATES=true
CHECK_PLACEHOLDERS=false
CHECK_METADATA=true
CHECK_TEMPLATE_SOURCE=true
CHECK_H2_EMOJIS=true
CHECK_CROSS_REFERENCES=false

load_enforcement_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    return
  fi

  if ! validate_json "$CONFIG_FILE" >/dev/null 2>&1; then
    return
  fi

  local base_path='.skills["conversation-documentation"].enforcementConfig'

  ENFORCEMENT_MODE=$(jq -r "$base_path.mode // \"hard-block\"" "$CONFIG_FILE" 2>/dev/null)
  VALIDATION_LEVEL=$(jq -r "$base_path.validationLevel // \"moderate\"" "$CONFIG_FILE" 2>/dev/null)
  CHECK_SPEC_FOLDER=$(jq -r "$base_path.checkSpecFolder // true" "$CONFIG_FILE" 2>/dev/null)
  CHECK_TEMPLATES=$(jq -r "$base_path.checkTemplates // true" "$CONFIG_FILE" 2>/dev/null)
  CHECK_PLACEHOLDERS=$(jq -r "$base_path.checkPlaceholders // false" "$CONFIG_FILE" 2>/dev/null)
  CHECK_METADATA=$(jq -r "$base_path.checkMetadata // true" "$CONFIG_FILE" 2>/dev/null)
  CHECK_TEMPLATE_SOURCE=$(jq -r "$base_path.checkTemplateSource // true" "$CONFIG_FILE" 2>/dev/null)
  CHECK_H2_EMOJIS=$(jq -r "$base_path.checkH2Emojis // true" "$CONFIG_FILE" 2>/dev/null)
  CHECK_CROSS_REFERENCES=$(jq -r "$base_path.checkCrossReferences // false" "$CONFIG_FILE" 2>/dev/null)
  MAX_EXCEPTION_LOC=$(jq -r "$base_path.allowedExceptions.maxLOC // 5" "$CONFIG_FILE" 2>/dev/null)
  SINGLE_FILE_ONLY=$(jq -r "$base_path.allowedExceptions.singleFileOnly // true" "$CONFIG_FILE" 2>/dev/null)

  # Bash 3.2 compatible: read patterns into array
  ALLOWED_EXCEPTION_PATTERNS=()
  while IFS= read -r pattern; do
    [ -n "$pattern" ] && ALLOWED_EXCEPTION_PATTERNS+=("$pattern")
  done < <(jq -r "$base_path.allowedExceptions.patterns[]?" "$CONFIG_FILE" 2>/dev/null)
}

exception_matches_prompt() {
  ALLOWED_EXCEPTION_REASON=""
  if [ ${#ALLOWED_EXCEPTION_PATTERNS[@]} -eq 0 ]; then
    return 1
  fi

  for pattern in "${ALLOWED_EXCEPTION_PATTERNS[@]}"; do
    local clean_pattern=$(echo "$pattern" | tr '[:upper:]' '[:lower:]')
    if [ -n "$clean_pattern" ] && [[ "$PROMPT_LOWER" == *"$clean_pattern"* ]]; then
      ALLOWED_EXCEPTION_REASON="$pattern"
      return 0
    fi
  done

  return 1
}

file_has_structure() {
  local file_path="$1"
  local size=$(wc -c < "$file_path" 2>/dev/null | tr -d ' ')
  if [ -z "$size" ] || [ "$size" -lt 200 ]; then
    return 1
  fi

  if ! grep -qE '^## [0-9]+\. ' "$file_path" 2>/dev/null; then
    return 1
  fi

  if [ "$CHECK_PLACEHOLDERS" = true ] && grep -qE '\[PLACEHOLDER|\[NEEDS CLARIFICATION' "$file_path" 2>/dev/null; then
    return 1
  fi

  return 0
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# NEW VALIDATION FUNCTIONS - Template Structure Enforcement
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Helper: Detect spec folder level based on file presence
detect_spec_level() {
  local spec_folder="$1"

  # Level 0: README.md only
  if [ -f "$spec_folder/README.md" ] && [ ! -f "$spec_folder/spec.md" ]; then
    echo "0"
    return
  fi

  # Level 1: spec.md only
  if [ -f "$spec_folder/spec.md" ] && [ ! -f "$spec_folder/plan.md" ]; then
    echo "1"
    return
  fi

  # Level 2/3: spec.md + plan.md
  if [ -f "$spec_folder/spec.md" ] && [ -f "$spec_folder/plan.md" ]; then
    echo "2"
    return
  fi

  echo "unknown"
}

# Helper: Extract metadata block from file (YAML frontmatter or ### Metadata section)
extract_metadata() {
  local file_path="$1"

  if [ ! -f "$file_path" ]; then
    echo ""
    return
  fi

  # Try YAML frontmatter (between --- markers)
  if head -n 1 "$file_path" 2>/dev/null | grep -q '^---$'; then
    sed -n '/^---$/,/^---$/p' "$file_path" 2>/dev/null | tail -n +2 | head -n -1
    return
  fi

  # Try Metadata section (### Metadata)
  if grep -q '^### Metadata' "$file_path" 2>/dev/null; then
    sed -n '/^### Metadata/,/^###/p' "$file_path" 2>/dev/null | tail -n +2 | head -n -1
    return
  fi

  echo ""
}

# Helper: Check if status value is valid
is_valid_status() {
  local status="$1"
  case "$status" in
    Draft|"In Review"|Approved|"In Progress"|Paused|Complete|Archived) return 0 ;;
    *) return 1 ;;
  esac
}

# Helper: Get required metadata fields for level
get_required_fields() {
  local level="$1"
  case "$level" in
    0) echo "date type level loc" ;;
    1) echo "created status level estimated_loc complexity" ;;
    2|3) echo "category tags priority status created level estimated_loc" ;;
    *) echo "" ;;
  esac
}

# Helper: Map file name to template name
map_file_to_template() {
  case "$1" in
    "spec.md") echo "spec_template.md" ;;
    "plan.md") echo "plan_template.md" ;;
    "tasks.md") echo "tasks_template.md" ;;
    "checklist.md") echo "checklist_template.md" ;;
    *) echo "unknown" ;;
  esac
}

# Helper: Suggest emoji for H2 heading based on content
suggest_emoji_for_heading() {
  local heading="$1"

  case "$heading" in
    *OBJECTIVE*) echo "ğŸ¯" ;;
    *SCOPE*) echo "ğŸ“‹" ;;
    *USER*|*STORIES*) echo "ğŸ‘¥" ;;
    *REQUIREMENT*) echo "ğŸ“" ;;
    *SUCCESS*) echo "âœ…" ;;
    *RISK*|*MITIGATION*) echo "âš ï¸" ;;
    *DEPEND*) echo "ğŸ”—" ;;
    *REFER*) echo "ğŸ“š" ;;
    *TEST*) echo "ğŸ§ª" ;;
    *IMPLEMENT*) echo "ğŸ› ï¸" ;;
    *PHASE*) echo "ğŸ“" ;;
    *QUALITY*) echo "ğŸ’" ;;
    *) echo "ğŸ“Œ" ;;  # Default
  esac
}

# Validation: Check for placeholder text (HARD BLOCK)
validate_placeholders() {
  local spec_folder="$1"
  local issues=()

  # Skip if check disabled
  if [ "$CHECK_PLACEHOLDERS" != "true" ]; then
    return 0
  fi

  # Scan all .md files in spec folder (excluding memory/)
  while IFS= read -r file; do
    if [ -f "$file" ]; then
      # Check for [PLACEHOLDER] or [NEEDS CLARIFICATION:
      if grep -qE '\[PLACEHOLDER\]|\[NEEDS CLARIFICATION' "$file" 2>/dev/null; then
        local lines=$(grep -nE '\[PLACEHOLDER\]|\[NEEDS CLARIFICATION' "$file" 2>/dev/null | head -5 | cut -d: -f1 | tr '\n' ',' | sed 's/,$//')
        issues+=("$(basename "$file"):$lines - Contains placeholder text")
      fi

      # Check for sample content blocks
      if grep -qE '<!-- SAMPLE CONTENT -->|REPLACE SAMPLE CONTENT' "$file" 2>/dev/null; then
        local lines=$(grep -nE '<!-- SAMPLE CONTENT -->|REPLACE SAMPLE CONTENT' "$file" 2>/dev/null | head -5 | cut -d: -f1 | tr '\n' ',' | sed 's/,$//')
        issues+=("$(basename "$file"):$lines - Contains sample content blocks")
      fi

      # Check for ACTION REQUIRED markers
      if grep -qE 'ACTION REQUIRED:' "$file" 2>/dev/null; then
        local lines=$(grep -n 'ACTION REQUIRED:' "$file" 2>/dev/null | head -5 | cut -d: -f1 | tr '\n' ',' | sed 's/,$//')
        issues+=("$(basename "$file"):$lines - Contains action required markers")
      fi
    fi
  done < <(find "$spec_folder" -maxdepth 1 -name "*.md" -not -path "*/memory/*" 2>/dev/null)

  if [ ${#issues[@]} -gt 0 ]; then
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âŒ HARD BLOCK: Placeholder text detected"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    printf '%s\n' "${issues[@]}"
    echo ""
    echo "You must replace all placeholder text before making file changes."
    echo "See: .claude/skills/workflows-conversation/references/template_guide.md"
    echo ""
    return 1  # Hard block
  fi

  return 0  # No issues
}

# Validation: Check for template source markers (SOFT WARNING)
validate_template_source() {
  local spec_folder="$1"
  local warnings=()

  # Skip if check disabled
  if [ "$CHECK_TEMPLATE_SOURCE" != "true" ]; then
    return 0
  fi

  # Check core spec files for template markers
  local core_files=("spec.md" "plan.md" "README.md")

  for file_name in "${core_files[@]}"; do
    local file_path="$spec_folder/$file_name"

    if [ -f "$file_path" ]; then
      # Check first 10 lines for marker
      if ! head -n 10 "$file_path" 2>/dev/null | grep -q 'SPECKIT_TEMPLATE_SOURCE:'; then
        local suggested_template=$(map_file_to_template "$file_name")
        if [ "$suggested_template" != "unknown" ]; then
          warnings+=("$file_name - Missing template source marker")
          warnings+=("  â†’ Suggested: cp .opencode/speckit/templates/$suggested_template $file_path")
        fi
      fi
    fi
  done

  if [ ${#warnings[@]} -gt 0 ]; then
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "âš ï¸  WARNING: Template source validation"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    printf '%s\n' "${warnings[@]}"
    echo ""
    echo "Files should be copied from .opencode/speckit/templates/ for consistency."
    echo ""
    return 1  # Soft warning (not blocking)
  fi

  return 0  # No issues
}

# Validation: Check metadata block completeness (SOFT WARNING)
validate_metadata_block() {
  local spec_folder="$1"
  local warnings=()

  # Skip if check disabled
  if [ "$CHECK_METADATA" != "true" ]; then
    return 0
  fi

  local level=$(detect_spec_level "$spec_folder")

  # Check spec.md or README.md for metadata
  local spec_file="$spec_folder/spec.md"
  [ -f "$spec_folder/README.md" ] && spec_file="$spec_folder/README.md"

  if [ ! -f "$spec_file" ]; then
    return 0  # No spec file to validate
  fi

  # Extract metadata block
  local metadata=$(extract_metadata "$spec_file")

  if [ -z "$metadata" ]; then
    warnings+=("No metadata block found in $(basename "$spec_file")")
    warnings+=("  â†’ Consider adding metadata section for better organization")
  else
    # Get required fields for level
    local required_fields=$(get_required_fields "$level")

    if [ -n "$required_fields" ]; then
      # Check each required field
      for field in $required_fields; do
        if ! echo "$metadata" | grep -qiE "^[- ]*$field:" 2>/dev/null; then
          warnings+=("Missing metadata field for Level $level: $field")
        fi
      done
    fi

    # Validate status field if present
    if echo "$metadata" | grep -qiE "^[- ]*status:" 2>/dev/null; then
      local status=$(echo "$metadata" | grep -iE "^[- ]*status:" | sed 's/.*status:\s*//' | sed 's/[[:space:]]*$//' | tr -d '[]"' | head -1)
      if ! is_valid_status "$status"; then
        warnings+=("Invalid status value: '$status'")
        warnings+=("  â†’ Valid: Draft | In Review | Approved | In Progress | Paused | Complete | Archived")
      fi
    fi
  fi

  if [ ${#warnings[@]} -gt 0 ]; then
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "âš ï¸  WARNING: Metadata validation (Level $level)"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    printf '%s\n' "${warnings[@]}"
    echo ""
    return 1  # Soft warning (not blocking)
  fi

  return 0  # No issues
}

# Validation: Check H2 emoji usage (SUGGESTION)
validate_h2_emojis() {
  local spec_folder="$1"
  local suggestions=()

  # Skip if check disabled
  if [ "$CHECK_H2_EMOJIS" != "true" ]; then
    return 0
  fi

  while IFS= read -r file; do
    if [ -f "$file" ]; then
      local filename=$(basename "$file")

      # Check H2 headings without emojis (## N. TEXT without emoji)
      while IFS= read -r line; do
        if [ -n "$line" ]; then
          local line_num=$(echo "$line" | cut -d: -f1)
          local heading=$(echo "$line" | cut -d: -f2- | sed 's/^## [0-9]*\. //')

          # Skip if heading already starts with common emoji patterns (simple character check)
          # Check for emoji-like characters at start (most emojis are multi-byte UTF-8)
          local first_chars=$(echo "$heading" | cut -c1-3)
          if echo "$first_chars" | LC_ALL=C grep -q '[^ -~]' 2>/dev/null; then
            # Contains non-ASCII character at start, likely emoji
            continue
          fi

          local suggested_emoji=$(suggest_emoji_for_heading "$heading")
          suggestions+=("$filename:$line_num - H2 without emoji, suggest: $suggested_emoji $heading")
        fi
      done < <(grep -nE '^## [0-9]+\. [A-Z]' "$file" 2>/dev/null || true)
    fi
  done < <(find "$spec_folder" -maxdepth 1 -name "*.md" -not -path "*/memory/*" 2>/dev/null)

  if [ ${#suggestions[@]} -gt 0 ]; then
    # Limit suggestions to first 5 to avoid overwhelming output
    local limited_suggestions=("${suggestions[@]:0:5}")

    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "ğŸ’¡ SUGGESTION: H2 emoji validation"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    printf '%s\n' "${limited_suggestions[@]}"
    if [ ${#suggestions[@]} -gt 5 ]; then
      echo "  ... and $((${#suggestions[@]} - 5)) more"
    fi
    echo ""
    echo "H2 sections should include emojis for visual scanning."
    echo ""
    return 1  # Suggestion (not blocking)
  fi

  return 0  # No issues
}

# Validation: Check cross-references (SOFT WARNING)
validate_cross_references() {
  local spec_folder="$1"
  local warnings=()

  # Skip if check disabled
  if [ "$CHECK_CROSS_REFERENCES" != "true" ]; then
    return 0
  fi

  while IFS= read -r file; do
    if [ -f "$file" ]; then
      local filename=$(basename "$file")

      # Extract markdown links to .md files
      while IFS= read -r link; do
        if [ -n "$link" ]; then
          # Resolve relative path
          local target_path
          if [[ "$link" == ./* ]]; then
            target_path="$(dirname "$file")/${link#./}"
          else
            target_path="$(dirname "$file")/$link"
          fi

          # Check if target exists
          if [ ! -f "$target_path" ]; then
            warnings+=("$filename - Broken link: $link (target not found)")
          fi
        fi
      done < <(grep -oE '\[.*\]\([^)]+\.md\)' "$file" 2>/dev/null | grep -oE '\([^)]+\.md\)' | tr -d '()' || true)
    fi
  done < <(find "$spec_folder" -maxdepth 1 -name "*.md" -not -path "*/memory/*" 2>/dev/null)

  if [ ${#warnings[@]} -gt 0 ]; then
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "âš ï¸  WARNING: Cross-reference validation"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    printf '%s\n' "${warnings[@]}"
    echo ""
    echo "Fix broken links or create missing target files."
    echo ""
    return 1  # Soft warning (not blocking)
  fi

  return 0  # No issues
}

# Suggestion: Sub-folder README
suggest_subfolder_readme() {
  local spec_folder="$1"
  local current_path="$PWD"

  # Check if we're in a sub-folder of the spec folder
  if [[ "$current_path" == "$spec_folder"/* ]] && [[ "$current_path" != "$spec_folder" ]]; then
    # We're in a sub-folder
    local subfolder_name=$(basename "$current_path")

    # Skip memory/ sub-folder
    if [ "$subfolder_name" = "memory" ]; then
      return 0
    fi

    # Check if README.md exists
    if [ ! -f "$current_path/README.md" ]; then
      echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
      echo "ğŸ’¡ SUGGESTION: Sub-folder organization"
      echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
      echo ""
      echo "You're working in sub-folder: $subfolder_name"
      echo ""
      echo "Consider creating a README.md to document this sub-folder's purpose:"
      echo "  cp .opencode/speckit/templates/subfolder_readme_template.md $current_path/README.md"
      echo ""
      echo "See: .claude/skills/workflows-conversation/references/template_guide.md"
      echo "     (Section: 'Using Sub-Folders for Organization')"
      echo ""
      return 1  # Suggestion (not blocking)
    fi
  fi

  return 0  # No suggestion needed
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VALIDATION_ERRORS=()

validate_templates() {
  local folder="$1"
  VALIDATION_ERRORS=()

  if [ ! -d "$folder" ]; then
    VALIDATION_ERRORS+=("Spec folder not found at $folder")
    return 1
  fi

  local spec_file="$folder/spec.md"
  local readme_file="$folder/README.md"
  local plan_file="$folder/plan.md"

  local has_valid_spec=false
  local has_valid_readme=false

  if [ -f "$spec_file" ] && file_has_structure "$spec_file"; then
    has_valid_spec=true
  fi

  if [ -f "$readme_file" ] && file_has_structure "$readme_file"; then
    has_valid_readme=true
  fi

  if [ "$has_valid_spec" = false ] && [ "$has_valid_readme" = false ]; then
    VALIDATION_ERRORS+=("spec.md or README.md missing/too small (<200 bytes) or missing numbered sections")
  fi

  if [ "$VALIDATION_LEVEL" = "strict" ] && [ -f "$spec_file" ] && ! file_has_structure "$plan_file"; then
    VALIDATION_ERRORS+=("plan.md missing or incomplete for strict validation")
  fi

  if [ ${#VALIDATION_ERRORS[@]} -gt 0 ]; then
    return 1
  fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # NEW VALIDATION CHECKS - Template Structure Enforcement
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  local has_hard_block=false
  local has_warnings=false
  local has_suggestions=false

  # Run placeholder validation (HARD BLOCK)
  if ! validate_placeholders "$folder" 2>&1; then
    has_hard_block=true
  fi

  # If hard block detected, stop here and return failure
  if [ "$has_hard_block" = true ]; then
    return 1
  fi

  # Run remaining validations (warnings and suggestions)
  if ! validate_template_source "$folder" 2>&1; then
    has_warnings=true
  fi

  if ! validate_metadata_block "$folder" 2>&1; then
    has_warnings=true
  fi

  if ! validate_h2_emojis "$folder" 2>&1; then
    has_suggestions=true
  fi

  if ! validate_cross_references "$folder" 2>&1; then
    has_warnings=true
  fi

  if ! suggest_subfolder_readme "$folder" 2>&1; then
    has_suggestions=true
  fi

  # Warnings and suggestions don't block, just inform
  return 0
}

find_latest_spec_folder() {
  if [ ! -d "$SPECS_DIR" ]; then
    return
  fi

  local latest=$(find "$SPECS_DIR" -maxdepth 1 -mindepth 1 -type d -name "[0-9]*-*" 2>/dev/null | sort | tail -1)
  echo "$latest"
}

calculate_next_spec_number() {
  if [ ! -d "$SPECS_DIR" ]; then
    printf "%03d" 1
    return
  fi

  local max=0
  while IFS= read -r dir; do
    local base=$(basename "$dir")
    local num=${base%%-*}
    if [[ "$num" =~ ^[0-9]+$ ]]; then
      if ((10#$num > max)); then
        max=$((10#$num))
      fi
    fi
  done < <(find "$SPECS_DIR" -maxdepth 1 -mindepth 1 -type d -name "[0-9]*-*" 2>/dev/null)

  printf "%03d" $((max + 1))
}

NEXT_SPEC_NUMBER=$(calculate_next_spec_number)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DETECT MID-CONVERSATION STATE USING STATE MARKER
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Check if there's an active spec folder using explicit state tracking.
# Uses .claude/.spec-active marker file instead of fragile heuristics.
#
# Marker file contains the path to the currently active spec folder.
# Create marker: create_spec_marker "specs/095-feature-name"
# Cleanup marker: cleanup_spec_marker
#
# Returns:
#   0 - Mid-conversation (marker exists, skip validation)
#   1 - Start of conversation (no marker, run validation)

SPEC_MARKER=".claude/.spec-active"
SKIP_MARKER=".claude/.spec-skip"

has_substantial_content() {
  local spec_folder="$1"

  # Check if state marker file exists
  if [ -f "$SPEC_MARKER" ]; then
    # Marker exists - we're mid-conversation
    local active_spec=$(cat "$SPEC_MARKER" 2>/dev/null)

    # Verify the marked spec folder actually exists
    if [ -d "$active_spec" ]; then
      return 0  # Mid-conversation
    else
      # Stale marker - cleanup and treat as start of conversation
      cleanup_spec_marker
      return 1
    fi
  fi

  # No marker - check for actual content in folder (including sub-folders)
  # This handles cases where work exists but marker was cleared
  if [ -n "$spec_folder" ] && [ -d "$spec_folder" ]; then
    # Count MD files recursively (root + sub-folders)
    local md_count
    md_count=$(find "$spec_folder" -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')

    # Consider substantial if 2+ MD files exist (spec.md + at least one other)
    if [ "$md_count" -ge 2 ]; then
      return 0  # Has substantial content
    fi
  fi

  # No marker and no substantial content - start of conversation
  return 1
}

# Create state marker when spec folder is created
create_spec_marker() {
  local spec_path="$1"

  if [ -z "$spec_path" ]; then
    return 1
  fi

  # Ensure .claude directory exists
  mkdir -p .claude

  # Write spec path to marker file
  echo "$spec_path" > "$SPEC_MARKER"
}

# Cleanup state marker (call when conversation ends or manually)
cleanup_spec_marker() {
  rm -f "$SPEC_MARKER"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SKIP MARKER FUNCTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Allow users to explicitly skip spec folder creation for trivial
# explorations. Creates .claude/.spec-skip marker to remember decision.

# Check if skip marker exists
has_skip_marker() {
  [ -f "$SKIP_MARKER" ]
}

# Create skip marker when user selects skip option
create_skip_marker() {
  # Ensure .claude directory exists
  mkdir -p .claude

  # Write skip marker (content not used, just existence check)
  echo "skip" > "$SKIP_MARKER"
}

# Cleanup skip marker (call manually to re-enable spec folder prompts)
cleanup_skip_marker() {
  rm -f "$SKIP_MARKER"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SUB-FOLDER VERSIONING FUNCTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Support for iterative work patterns within single spec folders.
# When reusing existing spec folders, automatically create sub-folders
# to separate iterations while maintaining independent memory contexts.

# Check if spec folder has root-level content (needs migration to sub-folders)
has_root_level_content() {
  local spec_folder="$1"

  if [ -z "$spec_folder" ] || [ ! -d "$spec_folder" ]; then
    return 1
  fi

  # Check for any markdown files at root level (excluding directories)
  local root_md_count=$(find "$spec_folder" -maxdepth 1 -type f -name "*.md" 2>/dev/null | wc -l | tr -d ' ')

  if [ "$root_md_count" -gt 0 ]; then
    return 0  # Has root content
  fi

  return 1  # No root content
}

# Find next sub-folder number within spec folder
# Returns next available number in format: 001, 002, 003, etc.
get_next_subfolder_number() {
  local spec_folder="$1"

  if [ ! -d "$spec_folder" ]; then
    echo "001"
    return
  fi

  # Find all numbered sub-folders (###-*)
  local max=0
  while IFS= read -r dir; do
    local base=$(basename "$dir")
    local num=${base%%-*}
    # Check if it's a number with exactly 3 digits
    if [[ "$num" =~ ^[0-9]{3}$ ]]; then
      # Force base 10 interpretation to avoid octal issues
      if ((10#$num > max)); then
        max=$((10#$num))
      fi
    fi
  done < <(find "$spec_folder" -maxdepth 1 -mindepth 1 -type d -name "[0-9][0-9][0-9]-*" 2>/dev/null)

  # Return next number with 3-digit padding
  printf "%03d" $((max + 1))
}

# Get parent folder from a path (handles both ###-parent and ###-parent/###-child)
# Returns parent folder path, or empty if path is not in numbered folder
get_parent_folder() {
  local path="$1"

  if [ -z "$path" ]; then
    return 1
  fi

  # Get absolute path
  if [[ "$path" != /* ]]; then
    path="$PROJECT_ROOT/$path"
  fi

  # Check if path itself is a numbered folder at specs level
  # Pattern: /path/to/specs/###-name (no trailing slash or subdirectory)
  if [[ "$path" =~ /specs/[0-9][0-9][0-9]-[^/]+$ ]]; then
    # Path is already a parent folder (###-name)
    echo "$path"
    return 0
  fi

  # Check if path is a child folder (###-parent/###-child)
  # Pattern: /path/to/specs/###-parent/###-child
  if [[ "$path" =~ (/specs/[0-9][0-9][0-9]-[^/]+)/[0-9][0-9][0-9]- ]]; then
    # Extract parent folder from match (full path up to parent)
    local parent_suffix="${BASH_REMATCH[1]}"
    # Get the full path by taking everything before /specs/ and appending the match
    local base_path="${path%%/specs/*}"
    echo "${base_path}${parent_suffix}"
    return 0
  fi

  # Not a numbered folder
  return 1
}

# Check if marker is stale (points to unrelated work based on keywords)
# Returns 0 if stale, 1 if fresh (keyword match found)
check_marker_staleness() {
  local prompt_keywords="$1"
  local marker_path="$2"

  if [ -z "$prompt_keywords" ] || [ -z "$marker_path" ]; then
    return 1  # Cannot determine, assume fresh
  fi

  # Extract folder names from marker path (both parent and child)
  local parent_folder=$(basename "$(dirname "$marker_path")")
  local child_folder=$(basename "$marker_path")

  # Check if any keyword matches parent or child folder
  while IFS= read -r keyword; do
    [ -z "$keyword" ] && continue

    # Check parent folder
    if echo "$parent_folder" | grep -qiE "$keyword"; then
      return 1  # Fresh (keyword match in parent)
    fi

    # Check child folder
    if echo "$child_folder" | grep -qiE "$keyword"; then
      return 1  # Fresh (keyword match in child)
    fi
  done <<< "$prompt_keywords"

  return 0  # Stale (no keyword match)
}

# Sync global marker to local marker in parent folder
# Creates/updates local .spec-active marker from global marker state
# Returns 0 on success, 1 on failure or if sync not needed
sync_marker_to_parent() {
  local global_marker="$SPEC_MARKER"

  # Check if global marker exists
  if [ ! -f "$global_marker" ]; then
    return 1
  fi

  # Read global marker
  local active_path=$(cat "$global_marker" 2>/dev/null | tr -d '\n')

  # Validate path exists
  if [ -z "$active_path" ] || [ ! -d "$active_path" ]; then
    # Clean up stale marker
    rm -f "$global_marker" 2>/dev/null
    log_event "MARKER_SYNC" "Cleaned up stale global marker (path: $active_path)"
    return 1
  fi

  # Determine parent folder
  local parent_folder=$(get_parent_folder "$active_path")

  if [ -z "$parent_folder" ]; then
    # Not a spec folder path, no sync needed
    return 1
  fi

  # Create local marker path
  local local_marker="$parent_folder/.spec-active"
  local child_name=$(basename "$active_path")

  # Check if local marker already has correct value
  if [ -f "$local_marker" ]; then
    local existing_value=$(cat "$local_marker" 2>/dev/null | tr -d '\n')
    if [ "$existing_value" = "$child_name" ]; then
      # Already synced, no action needed
      return 0
    fi
  fi

  # Write atomically (tmp file with PID + mv to prevent race conditions)
  local tmp_file="${local_marker}.tmp.$$"
  if echo "$child_name" > "$tmp_file" 2>/dev/null && mv "$tmp_file" "$local_marker" 2>/dev/null; then
    log_event "MARKER_SYNC" "Synced local marker: $parent_folder/.spec-active â†’ $child_name"
    return 0
  else
    # Cleanup failed tmp file
    rm -f "$tmp_file" 2>/dev/null
    log_event "MARKER_SYNC" "Failed to sync local marker (permission denied or disk full?)"
    return 1
  fi
}

# Check if folder is a parent folder (contains numbered sub-folders ###-*)
# Returns 0 (true) if folder has numbered sub-folders, 1 (false) otherwise
# Used to differentiate organizational parent folders from working spec folders
is_parent_folder() {
  local folder="$1"

  if [ ! -d "$folder" ]; then
    return 1
  fi

  # Check for numbered sub-folders (###-*)
  local child_count=$(find "$folder" -maxdepth 1 -mindepth 1 -type d -name "[0-9][0-9][0-9]-*" 2>/dev/null | wc -l | tr -d ' ')

  if [ "$child_count" -gt 0 ]; then
    return 0  # Is parent
  fi

  return 1  # Not parent
}

# Get active child folder from parent via .spec-active marker
# Returns active child path if marker exists and child is valid, empty otherwise
# Used to determine which child folder is currently active in parent
get_active_child() {
  local parent_folder="$1"

  if [ ! -d "$parent_folder" ]; then
    return 1
  fi

  # Check for .spec-active marker
  local marker_file="$parent_folder/.spec-active"
  if [ ! -f "$marker_file" ]; then
    return 1
  fi

  # Read active child path from marker
  local active_path=$(cat "$marker_file" 2>/dev/null | tr -d '\n')

  # Validate active child exists
  if [ -n "$active_path" ] && [ -d "$active_path" ]; then
    echo "$active_path"
    return 0
  fi

  return 1
}

# Migrate spec folder to sub-folder structure
# Creates numbered archive sub-folder for existing content and numbered sub-folder for new work
migrate_to_subfolders() {
  local spec_folder="$1"
  local new_subfolder_name="$2"

  # Input validation
  if [ -z "$spec_folder" ] || [ -z "$new_subfolder_name" ]; then
    echo "   âš ï¸  Migration failed: Invalid parameters" >&2
    return 1
  fi

  if [ ! -d "$spec_folder" ]; then
    echo "   âš ï¸  Migration failed: Spec folder not found" >&2
    return 1
  fi

  # Validate sub-folder name format (lowercase, hyphens, alphanumeric)
  if ! echo "$new_subfolder_name" | grep -qE '^[a-z][a-z0-9-]*$'; then
    echo "   âš ï¸  Invalid sub-folder name: Use lowercase letters, numbers, and hyphens only" >&2
    echo "   Examples: spec-folder-versioning, api-refactor, bug-fixes" >&2
    return 1
  fi

  # Get next sub-folder number for archive
  local archive_num=$(get_next_subfolder_number "$spec_folder")

  # Calculate new sub-folder number (archive + 1)
  local new_num=$(printf "%03d" $((10#$archive_num + 1)))

  # Create folder names with numbers
  local spec_basename=$(basename "$spec_folder")
  local archive_topic="${spec_basename#*-}"  # Remove ###- prefix
  local archive_folder="${spec_folder}/${archive_num}-${archive_topic}"
  local new_folder="${spec_folder}/${new_num}-${new_subfolder_name}"

  # Check for conflicts
  if [ -d "$archive_folder" ]; then
    echo "   âš ï¸  Archive folder already exists: $(basename "$archive_folder")" >&2
    return 1
  fi

  if [ -d "$new_folder" ]; then
    echo "   âš ï¸  Sub-folder already exists: $(basename "$new_folder")" >&2
    echo "   Choose a different name or work in existing folder" >&2
    return 1
  fi

  # Create sub-folders
  echo "   ğŸ“¦ Creating sub-folder structure..." >&2
  mkdir -p "$archive_folder" || {
    echo "   âš ï¸  Failed to create archive folder" >&2
    return 1
  }

  mkdir -p "$new_folder/memory" || {
    echo "   âš ï¸  Failed to create new sub-folder" >&2
    rm -rf "$archive_folder"  # Cleanup partial creation
    return 1
  }

  # Move existing root-level files to archive (exclude directories)
  echo "   ğŸ“¦ Archiving existing files..." >&2
  find "$spec_folder" -maxdepth 1 -type f \( -name "*.md" -o -name "*.json" -o -name "*.txt" \) \
    -exec mv {} "$archive_folder/" \; 2>/dev/null

  # Move existing memory/ to archive if exists
  if [ -d "${spec_folder}/memory" ]; then
    echo "   ğŸ“¦ Archiving existing memory/ folder..." >&2
    mv "${spec_folder}/memory" "${archive_folder}/" 2>/dev/null || {
      echo "   âš ï¸  Warning: Could not move memory/ folder" >&2
    }
  fi

  # Update .spec-active marker to point to new sub-folder
  create_spec_marker "$new_folder"

  echo "   âœ… Migration complete:" >&2
  echo "      Archive: $(basename "$archive_folder")/" >&2
  echo "      Active: $(basename "$new_folder")/" >&2
  echo "      Marker: .claude/.spec-active updated" >&2

  return 0
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MEMORY FILE SELECTION FUNCTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Support for loading previous session context from memory files.
# Presents user with options to load recent memory files when continuing work.

# Find memory directory (sub-folder aware via .spec-active marker)
# Enhanced to traverse parent hierarchy and check related folders
find_memory_directory() {
  local spec_folder="$1"

  if [ -z "$spec_folder" ] || [ ! -d "$spec_folder" ]; then
    return 1
  fi

  # Check if .spec-active marker points to a sub-folder
  if [ -f "$SPEC_MARKER" ]; then
    local active_path=$(cat "$SPEC_MARKER" 2>/dev/null | tr -d '\n')

    # Validate marker points to existing directory
    if [ -n "$active_path" ] && [ -d "$active_path" ]; then

      # OPTION 1: Direct match - marker points to child of this spec
      if [[ "$active_path" == "$spec_folder"/* ]] && [ -d "$active_path/memory" ]; then
        echo "$active_path/memory"
        return 0
      fi

      # OPTION 2: Same parent - check if marker parent matches spec parent
      local marker_parent=$(get_parent_folder "$active_path")
      local spec_parent=$(get_parent_folder "$spec_folder")

      if [ -n "$marker_parent" ] && [ -n "$spec_parent" ] && [ "$marker_parent" = "$spec_parent" ]; then
        # Marker and spec are in same parent folder (siblings or same)
        if [ -d "$active_path/memory" ]; then
          echo "$active_path/memory"
          return 0
        fi
      fi

      # OPTION 3: Related parent - check if both are in same spec family
      # (same root number - e.g., 003-speckit-refinement and 003-speckit-rework)
      if [ -n "$marker_parent" ] && [ -n "$spec_parent" ]; then
        local marker_root=$(basename "$marker_parent" | sed 's/^\([0-9][0-9][0-9]\)-.*/\1/')
        local spec_root=$(basename "$spec_parent" | sed 's/^\([0-9][0-9][0-9]\)-.*/\1/')

        if [ -n "$marker_root" ] && [ -n "$spec_root" ] && [ "$marker_root" = "$spec_root" ]; then
          # Same spec family - use marker's memory directory
          if [ -d "$active_path/memory" ]; then
            echo "$active_path/memory"
            return 0
          fi
        fi
      fi

    else
      # Stale marker pointing to deleted folder - clean up and warn
      if [ -n "$active_path" ]; then
        rm -f "$SPEC_MARKER" 2>/dev/null
        log_event "MARKER_CLEANUP" "Removed stale .spec-active marker (path: $active_path)" 2>/dev/null || true
        # Return error - don't silently fallback to wrong directory
        echo "âš ï¸  Warning: Stale marker pointed to deleted folder: $active_path" >&2
        # Continue to fallback below, but log the warning
      fi
    fi
  fi

  # Fallback: use root memory/ if it exists (only if no stale marker was found)
  if [ -d "$spec_folder/memory" ]; then
    echo "$spec_folder/memory"
    return 0
  fi

  return 1
}

# List recent memory files (sorted by timestamp, most recent first)
list_recent_memory_files() {
  local memory_dir="$1"
  local limit="${2:-3}"

  if [ ! -d "$memory_dir" ]; then
    return 1
  fi

  # Find all memory files matching pattern: DD-MM-YY_HH-MM__topic.md
  find "$memory_dir" -maxdepth 1 -type f -name "*__*.md" 2>/dev/null \
    | sort -r \
    | head -n "$limit"
}

# Extract metadata from memory file's metadata.json
extract_memory_metadata() {
  local memory_dir="$1"
  local metadata_file="$memory_dir/metadata.json"

  # Default values if metadata doesn't exist
  local message_count="?"
  local decision_count="?"
  local timestamp="?"

  # Validate metadata file exists and is readable
  if [ ! -f "$metadata_file" ]; then
    echo "${message_count},${decision_count},${timestamp}"
    return 1
  fi

  if [ ! -r "$metadata_file" ]; then
    echo "${message_count},${decision_count},${timestamp}"
    return 1
  fi

  # Validate JSON format before parsing
  if ! validate_json "$metadata_file" >/dev/null 2>&1; then
    echo "${message_count},${decision_count},${timestamp}"
    return 1
  fi

  # Extract fields with error handling
  message_count=$(jq -r '.messageCount // "?"' "$metadata_file" 2>/dev/null || echo "?")
  decision_count=$(jq -r '.decisionCount // "?"' "$metadata_file" 2>/dev/null || echo "?")
  timestamp=$(jq -r '.timestamp // "?"' "$metadata_file" 2>/dev/null || echo "?")

  echo "${message_count},${decision_count},${timestamp}"
  return 0
}

# Calculate relative time from timestamp (DD-MM-YY_HH-MM format)
calculate_relative_time() {
  local filename="$1"

  # Validate input
  if [ -z "$filename" ]; then
    echo "unknown"
    return 1
  fi

  # Extract timestamp from filename (DD-MM-YY_HH-MM__topic.md)
  local timestamp=$(echo "$filename" | grep -oE '[0-9]{2}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}' | head -1)

  if [ -z "$timestamp" ]; then
    echo "unknown"
    return 1
  fi

  # Parse timestamp: DD-MM-YY_HH-MM
  local day=$(echo "$timestamp" | cut -d'-' -f1)
  local month=$(echo "$timestamp" | cut -d'-' -f2)
  local year=$(echo "$timestamp" | cut -d'-' -f3 | cut -d'_' -f1)
  local hour=$(echo "$timestamp" | cut -d'_' -f2 | cut -d'-' -f1)
  local minute=$(echo "$timestamp" | cut -d'-' -f4)

  # Validate extracted components
  if [ -z "$day" ] || [ -z "$month" ] || [ -z "$year" ] || [ -z "$hour" ] || [ -z "$minute" ]; then
    echo "unknown"
    return 1
  fi

  # Validate numeric ranges
  if [ "$day" -lt 1 ] || [ "$day" -gt 31 ] || \
     [ "$month" -lt 1 ] || [ "$month" -gt 12 ] || \
     [ "$hour" -lt 0 ] || [ "$hour" -gt 23 ] || \
     [ "$minute" -lt 0 ] || [ "$minute" -gt 59 ]; then
    echo "unknown"
    return 1
  fi

  # Convert to full year (20XX format)
  local full_year="20${year}"

  # Get current time in seconds since epoch
  local now=$(date +%s 2>/dev/null)
  if [ -z "$now" ]; then
    echo "unknown"
    return 1
  fi

  # Convert file timestamp to seconds since epoch (format: YYYY-MM-DD HH:MM:SS)
  # Platform-specific date command syntax
  local file_time=""
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: use -j flag
    file_time=$(date -j -f "%Y-%m-%d %H:%M:%S" "${full_year}-${month}-${day} ${hour}:${minute}:00" +%s 2>/dev/null)
  else
    # Linux: use -d flag
    file_time=$(date -d "${full_year}-${month}-${day} ${hour}:${minute}:00" +%s 2>/dev/null)
  fi

  if [ -z "$file_time" ] || [ "$file_time" = "" ]; then
    echo "unknown"
    return 1
  fi

  # Calculate difference in seconds
  local diff=$((now - file_time))

  # Handle negative differences (file in future - clock skew)
  if [ $diff -lt 0 ]; then
    echo "recent"
    return 0
  fi

  # Convert to human-readable format
  if [ $diff -lt 3600 ]; then
    # Less than 1 hour
    local minutes=$((diff / 60))
    if [ $minutes -lt 1 ]; then
      echo "just now"
    else
      echo "${minutes} min ago"
    fi
  elif [ $diff -lt 86400 ]; then
    # Less than 1 day
    local hours=$((diff / 3600))
    echo "${hours}h ago"
  else
    # Days
    local days=$((diff / 86400))
    if [ $days -eq 1 ]; then
      echo "1d ago"
    else
      echo "${days}d ago"
    fi
  fi

  return 0
}

# Load spec.md summary (objective, status, key info)
load_spec_summary() {
  local spec_folder="$1"
  local spec_file="$spec_folder/spec.md"

  if [ ! -f "$spec_file" ]; then
    return 1
  fi

  # Extract metadata from spec.md
  local metadata=$(extract_metadata "$spec_file")
  local status="?"
  local level="?"
  local estimated_loc="?"

  if [ -n "$metadata" ]; then
    status=$(echo "$metadata" | grep -iE "^[- ]*status:" | sed 's/.*status:\s*//' | sed 's/[[:space:]]*$//' | tr -d '[]"' | head -1)
    level=$(echo "$metadata" | grep -iE "^[- ]*level:" | sed 's/.*level:\s*//' | sed 's/[[:space:]]*$//' | tr -d '[]"' | head -1)
    estimated_loc=$(echo "$metadata" | grep -iE "^[- ]*estimated_loc:" | sed 's/.*estimated_loc:\s*//' | sed 's/[[:space:]]*$//' | tr -d '[]"' | head -1)
  fi

  # Extract objective (first paragraph after ## 1. Objective)
  local objective=""
  if grep -q '^## 1\. .*Objective' "$spec_file" 2>/dev/null; then
    objective=$(sed -n '/^## 1\. .*Objective/,/^##/p' "$spec_file" \
      | tail -n +2 \
      | head -n -1 \
      | grep -v '^$' \
      | head -3 \
      | tr '\n' ' ' \
      | sed 's/  */ /g')
  fi

  # Return formatted summary
  echo "STATUS:${status}|LEVEL:${level}|LOC:${estimated_loc}|OBJECTIVE:${objective}"
}

# Present memory selection prompt to user
present_memory_selection_prompt() {
  local spec_folder="$1"
  local memory_dir=$(find_memory_directory "$spec_folder")

  if [ -z "$memory_dir" ]; then
    # No memory directory found
    return 1
  fi

  # List recent memory files
  local recent_files=$(list_recent_memory_files "$memory_dir" 3)

  if [ -z "$recent_files" ]; then
    # No memory files found
    return 1
  fi

  # Load spec summary
  local spec_summary=$(load_spec_summary "$spec_folder")
  local status=$(echo "$spec_summary" | grep -oE 'STATUS:[^|]*' | cut -d':' -f2)
  local level=$(echo "$spec_summary" | grep -oE 'LEVEL:[^|]*' | cut -d':' -f2)
  local estimated_loc=$(echo "$spec_summary" | grep -oE 'LOC:[^|]*' | cut -d':' -f2)
  local objective=$(echo "$spec_summary" | grep -oE 'OBJECTIVE:.*' | cut -d':' -f2-)

  # Display spec context header
  echo ""
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "ğŸ“‹ SPEC CONTEXT AVAILABLE"
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo ""
  echo "Active Spec: $(basename "$spec_folder")/"

  if [ -n "$status" ] && [ "$status" != "?" ]; then
    echo "Status: $status | Level: $level | Est. LOC: ~${estimated_loc}"
  fi

  if [ -n "$objective" ] && [ "$objective" != "" ]; then
    echo ""
    echo "Current Objective:"
    echo "  ${objective:0:200}"
    if [ ${#objective} -gt 200 ]; then
      echo "  ..."
    fi
  fi

  # Display memory files section
  echo ""
  echo "ğŸ§  PREVIOUS SESSION CONTEXT"
  echo ""
  echo "Recent Memory Files:"

  local index=1
  while IFS= read -r file; do
    if [ -n "$file" ]; then
      local basename=$(basename "$file")
      local date_time=$(echo "$basename" | cut -d'_' -f1-2)
      local topic=$(echo "$basename" | cut -d'_' -f3- | sed 's/.md$//' | tr '_' ' ')
      local relative_time=$(calculate_relative_time "$basename")

      echo "  $index. $date_time - $topic ($relative_time)"
      index=$((index + 1))
    fi
  done <<< "$recent_files"

  # Display memory selection options (user-facing)
  echo ""
  echo "ğŸ“‚ Memory files from previous session(s):"
  echo "  A) Load most recent (file 1)"
  echo "  B) Load all recent (files 1-3)"
  echo "  C) List all memory files and select specific"
  echo "  D) Skip (start fresh)"
  echo ""
  echo "ğŸ”´ AI: Ask user to select A/B/C/D"
  echo ""
  # AI instructions block (parseable, separate from user display)
  echo "<!-- AI_INSTRUCTIONS"
  echo "After user selects option, execute:"
  echo "  A: Read file 1 using Read tool"
  echo "  B: Read files 1-3 using Read tool (parallel calls)"
  echo "  C: List up to 10 files, wait for user selection, then read"
  echo "  D: Proceed without loading memory files"
  echo "AI_INSTRUCTIONS -->"
  echo ""
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo ""

  return 0
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

estimate_documentation_level() {
  local text="$1"
  # Note: Level 0 eliminated. Typos are Level 1 (or exempt if single typo <5 chars)
  if echo "$text" | grep -qiE "typo|misspell|spelling|grammar|whitespace|rename|single file|small fix|docs only"; then
    echo 1
    return
  fi
  if echo "$text" | grep -qiE "architecture|system|platform|multiple services|rebuild|major refactor"; then
    echo 3
    return
  fi
  if echo "$text" | grep -qiE "feature|component|integration|workflow|refactor"; then
    echo 2
    return
  fi
  echo 2  # Default to Level 2
}

DOC_LEVEL=$(estimate_documentation_level "$PROMPT_LOWER")

get_level_label() {
  case "$DOC_LEVEL" in
    1) echo "1 (Simple)" ;;
    2) echo "2 (Moderate)" ;;
    3) echo "3 (Complex)" ;;
    *) echo "2 (Moderate)" ;;  # Default
  esac
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# RELATED SPEC DISCOVERY FUNCTIONS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

extract_keywords() {
  local text="$1"
  # Remove common stop words and extract significant terms
  # Also split compound words on hyphens for broader matching
  local keywords=$(echo "$text" | \
    tr '[:upper:]' '[:lower:]' | \
    tr '-' ' ' | \
    sed -E 's/\b(the|is|a|an|and|or|but|in|on|at|to|for|of|with|from)\b//g' | \
    tr -s ' ' '\n' | \
    grep -E '^[a-z]{2,}$' | \
    sort -u | \
    head -15)
  echo "$keywords"
}

get_spec_status() {
  local spec_folder="$1"
  local spec_file="$spec_folder/spec.md"

  if [ ! -f "$spec_file" ]; then
    echo "active"  # Default if spec.md missing
    return
  fi

  # Extract from YAML frontmatter (between --- markers)
  local status=$(awk '/^---$/,/^---$/ {if (/^status:/) {print $2; exit}}' "$spec_file" 2>/dev/null)

  # Default to "active" if missing
  echo "${status:-active}"
}

status_priority() {
  local status="$1"
  case "$status" in
    active) echo "1" ;;
    draft) echo "2" ;;
    paused) echo "3" ;;
    complete) echo "4" ;;
    archived) echo "5" ;;
    *) echo "1" ;; # Treat unknown as active
  esac
}

find_related_specs() {
  local prompt="$1"
  local keywords=$(extract_keywords "$prompt")

  if [ -z "$keywords" ] || [ ! -d "$SPECS_DIR" ]; then
    return
  fi

  # Separate parent matches from child matches (bash 3.2 compatible)
  declare -a parent_active
  declare -a parent_inactive
  declare -a child_matches

  # Array size limit to prevent memory exhaustion on large codebases
  local MAX_MATCHES=50

  # Helper to check if folder already in array
  folder_in_array() {
    local check="$1"
    shift
    local arr=("$@")
    for item in "${arr[@]}"; do
      # Extract folder path (before first colon)
      local folder="${item%%:*}"
      [[ "$folder" == "$check" ]] && return 0
    done
    return 1
  }

  # Search spec folder names for keyword matches
  while IFS= read -r keyword; do
    [ -z "$keyword" ] && continue

    while IFS= read -r folder; do
      [ -z "$folder" ] && continue
      local name=$(basename "$folder")

      # Skip if folder name is just numbers
      [[ "$name" =~ ^[0-9]+$ ]] && continue

      # Check if keyword matches folder name
      if echo "$name" | grep -qiE "$keyword"; then

        # Determine if parent or child folder
        if is_parent_folder "$folder"; then
          # Check for .spec-active marker
          local active_child=$(get_active_child "$folder")

          if [ -n "$active_child" ]; then
            # Active parent (has .spec-active marker)
            if ! folder_in_array "$folder" "${parent_active[@]}" && [[ ${#parent_active[@]} -lt $MAX_MATCHES ]]; then
              parent_active+=("$folder:$(basename "$active_child"):PARENT_ACTIVE")
            fi
          else
            # Inactive parent (no .spec-active marker)
            if ! folder_in_array "$folder" "${parent_inactive[@]}" && [[ ${#parent_inactive[@]} -lt $MAX_MATCHES ]]; then
              parent_inactive+=("$folder::PARENT_INACTIVE")
            fi
          fi
        else
          # Regular child/working folder
          if ! folder_in_array "$folder" "${child_matches[@]}" && [[ ${#child_matches[@]} -lt $MAX_MATCHES ]]; then
            local status=$(get_spec_status "$folder")
            local priority=$(status_priority "$status")
            child_matches+=("$priority:$folder:$status:CHILD")
          fi
        fi
      fi
    done < <(find "$SPECS_DIR" -maxdepth 1 -mindepth 1 -type d -name "[0-9]*-*" 2>/dev/null)
  done <<< "$keywords"

  # Prioritize: Active parents > Inactive parents > Child matches
  # For child matches, sort by status priority first
  {
    printf '%s\n' "${parent_active[@]}"
    printf '%s\n' "${parent_inactive[@]}"
    printf '%s\n' "${child_matches[@]}" | sort -t: -k1 -n
  } | head -3
}

print_template_guidance() {
  case "$DOC_LEVEL" in
    1)
      print_detail "cp .opencode/speckit/templates/spec_template.md specs/${NEXT_SPEC_NUMBER}-short-name/spec.md"
      ;;
    2)
      print_detail "cp .opencode/speckit/templates/spec_template.md specs/${NEXT_SPEC_NUMBER}-short-name/spec.md"
      print_detail "cp .opencode/speckit/templates/plan_template.md specs/${NEXT_SPEC_NUMBER}-short-name/plan.md"
      ;;
    3)
      print_detail "/speckit.specify (auto-generates Level 3 bundle)"
      ;;
  esac

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # COMPLEXITY-BASED TEMPLATE RECOMMENDATIONS (Phase 2: US4-7)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  if [ "$VALIDATION_LIB_LOADED" = true ]; then
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ’¡ ADDITIONAL TEMPLATE RECOMMENDATIONS:"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    local recommendations_made=false
    local user_input="$PROMPT"

    # Read complexity data from shared state (written by orchestrate-skill-validation.sh)
    # Falls back to defaults if state is stale (>60s) or unavailable
    local complexity_data
    complexity_data=$(read_hook_state "complexity" 60 2>/dev/null) || complexity_data=""
    local complexity_score=0
    local domain_count=1
    if [ -n "$complexity_data" ]; then
      complexity_score=$(echo "$complexity_data" | jq -r '.complexity_score // 0' 2>/dev/null) || complexity_score=0
      domain_count=$(echo "$complexity_data" | jq -r '.domain_count // 1' 2>/dev/null) || domain_count=1
    fi

    # Check for spike template need (investigation/POC work)
    local spike_result
    spike_result=$(detect_spike_needed "$user_input" "$complexity_score" 2>/dev/null) || spike_result=""

    if [ -n "$spike_result" ]; then
      recommendations_made=true
      echo "ğŸ”¬ Spike Template: [$spike_result]"
      echo "   Your task involves investigation/POC work"
      echo "   Command: cp .opencode/speckit/templates/spike_template.md specs/${NEXT_SPEC_NUMBER}-short-name/spike-[topic].md"
      echo ""
    fi

    # Check for research template need (exploration/comparison)
    local research_result
    research_result=$(detect_research_needed "$user_input" "$complexity_score" "$domain_count" 2>/dev/null) || research_result=""

    if [ -n "$research_result" ]; then
      recommendations_made=true
      echo "ğŸ“š Research Template: [$research_result]"
      echo "   Your task involves comprehensive research/exploration"
      echo "   Command: cp .opencode/speckit/templates/research_template.md specs/${NEXT_SPEC_NUMBER}-short-name/research.md"
      echo ""
    fi

    # Check for decision record need (architecture decisions)
    local decision_result
    decision_result=$(detect_decision_record_needed "$user_input" "$complexity_score" 2>/dev/null) || decision_result=""

    if [ -n "$decision_result" ]; then
      recommendations_made=true
      echo "ğŸ“‹ Decision Record Template: [$decision_result]"
      echo "   Your task involves architectural/technical decisions"
      echo "   Command: cp .opencode/speckit/templates/decision_record_template.md specs/${NEXT_SPEC_NUMBER}-short-name/decision-[topic].md"
      echo ""
    fi

    if [ "$recommendations_made" = false ]; then
      echo "No additional templates recommended for this task complexity"
    fi

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  fi
}

show_confirmation_prompt() {
  local reason="$1"
  local folder="$2"

  echo ""
  echo "âš ï¸  USER DECISION REQUIRED - MANDATORY DOCUMENTATION"
  echo "All file modifications MUST have proper spec folder documentation."
  echo "AI MUST ask user to select spec folder - DO NOT decide autonomously."
  echo "This is an INTERACTIVE prompt requiring explicit user response."
  echo ""
  echo "Detected modification intent: ${DETECTED_INTENT:-unknown}"
  echo "Estimated documentation level: $(get_level_label)"
  echo "Status: $reason"
  echo ""

  if [ -n "$folder" ]; then
    echo "Detected folder: $folder"
    echo ""

    # Check if folder has root-level content requiring migration
    if has_root_level_content "$folder"; then
      echo "ğŸ“¦ SUB-FOLDER VERSIONING WILL BE APPLIED"
      echo "The detected spec folder has existing files at root level."
      echo ""
      echo "If user selects Option A (use this folder), the system will:"
      echo "  1. Archive existing files to: 001-{topic}/"
      echo "  2. Prompt for new sub-folder name (e.g., 'api-refactor', 'versioning-enhancement')"
      echo "  3. Create new sub-folder: 002-{new-name}/"
      echo "  4. Each sub-folder will have independent memory/ context"
      echo ""
      echo "Sub-folder numbering: 001-archive, 002-new-work, 003-next-iteration, etc."
      echo ""
      echo "âš ï¸  AI: After user selects Option A, you MUST:"
      echo "  1. Ask user for new sub-folder name (lowercase, hyphens, 2-4 words)"
      echo "  2. Execute: .claude/hooks/lib/migrate-spec-folder.sh $folder <new-subfolder-name>"
      echo "  3. Create fresh spec.md and plan.md in new sub-folder"
      echo ""
      echo "Migration script usage:"
      echo "  .claude/hooks/lib/migrate-spec-folder.sh <spec-folder> <new-subfolder-name>"
      echo ""
    fi
  fi

  echo "âš¡ AI: ASK USER TO SELECT ONE OF THESE OPTIONS:"
  echo "DO NOT make this decision autonomously - user MUST choose explicitly."
  echo "Use clear question format: 'Which spec folder should we use?'"
  echo ""

  # Always show options A/B/C/D in consistent order
  if [ -n "$folder" ]; then
    # Folder detected: A=use, B=new, C=related, D=skip
    echo "  A) Use detected folder: $(basename "$folder")"
    echo "  B) Create new spec folder: specs/${NEXT_SPEC_NUMBER}-short-name/"
  else
    # No folder: A=new, B=different-number, C=related, D=skip
    echo "  A) Create new spec folder: specs/${NEXT_SPEC_NUMBER}-short-name/"
    echo "  B) Create spec with different number"
  fi

  # Option C: Related specs (if available)
  if [ -n "$RELATED_SPECS" ]; then
    echo "  C) Update one of the related specs shown above"
  fi

  # Option D: Skip (always shown)
  echo "  D) Skip spec folder creation (PROCEED WITHOUT DOCUMENTATION)"
  echo "     âš ï¸  WARNING: Skipping documentation creates technical debt"
  echo "     âš ï¸  Future debugging will be harder without context"
  echo "     âš ï¸  Use only for truly trivial explorations"

  # Check if folder has memory files and add guidance
  if [ -n "$folder" ]; then
    local memory_dir=$(find_memory_directory "$folder")
    if [ -n "$memory_dir" ] && [ -d "$memory_dir" ]; then
      local memory_file_count=$(find "$memory_dir" -maxdepth 1 -type f -name "*__*.md" 2>/dev/null | wc -l | tr -d ' ')
      if [ "$memory_file_count" -gt 0 ]; then
        echo ""
        echo "ğŸ§  MEMORY FILES DETECTED"
        echo "The detected spec folder contains $memory_file_count previous session file(s) in memory/."
        echo ""
        echo "âš ï¸  AI: If user selects Option A, you should ALSO:"
        echo "  1. Load spec summary from spec.md (objective, status, progress)"
        echo "  2. List recent memory files (3 most recent)"
        echo "  3. Ask user: 'Would you like to load previous session context?'"
        echo "     A) Load most recent memory file"
        echo "     B) Load all recent memory files (1-3)"
        echo "     C) List all and select specific"
        echo "     D) Skip (start fresh)"
        echo "  4. Read selected memory file(s) using Read tool"
        echo "  5. Summarize loaded context before continuing"
        echo ""
        echo "Memory files provide conversation history, decisions, and progress from previous sessions."
      fi
    fi
  fi

  echo ""
  echo "ğŸ“ Required format for your response:"
  echo "  Choice: [A/B/C/D]"
  echo "  Reason: [your explanation]"
  echo ""
  echo "ğŸ“ Next steps after choosing:"
  echo ""
  echo "If user selects D (Skip):"
  echo "  mkdir -p .claude && echo 'skip' > .claude/.spec-skip"
  echo "  (This creates skip marker to prevent future prompts)"
  echo ""
  echo "If user selects A/B/C (Create spec folder):"
  print_template_guidance
  echo ""
  echo "ğŸ“– Reference: $DOC_GUIDE"
  echo ""
  echo "âš ï¸  Do not start implementation until you've made your selection."
  echo "âš ï¸  This is an INTERACTIVE prompt - wait for user's explicit choice."
  echo ""
}

handle_confirmation() {
  local reason="$1"
  local folder="$2"
  log_event "CONFIRMATION_NEEDED" "$reason"
  show_confirmation_prompt "$reason" "$folder"

  # Always exit 0 to allow prompt to proceed to AI
  # AI will see confirmation request and respond accordingly
  return 0
}

handle_warning() {
  local reason="$1"
  log_event "WARNING" "$reason"
  print_warn_box "Documentation Warning" "$reason" "Mode: warning-only (execution allowed)"
}

if ! detect_modification_intent; then
  echo "âœ“ [enforce-spec-folder] No modification detected, skipping validation" >&2
  END_TIME=$(date +%s%N)
  DURATION=$(((END_TIME - START_TIME)/1000000))
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms" >> "$PERF_LOG"
  exit 0
fi

echo "âš¡ [enforce-spec-folder] Modification intent detected, validating spec folder..." >&2

load_enforcement_config

if exception_matches_prompt; then
  log_event "ALLOWED" "Exception matched: $ALLOWED_EXCEPTION_REASON"
  END_TIME=$(date +%s%N)
  DURATION=$(((END_TIME - START_TIME)/1000000))
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms" >> "$PERF_LOG"
  exit 0
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CHECK FOR SKIP MARKER
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If user previously selected skip option, allow conversation to proceed
# without spec folder validation

if has_skip_marker; then
  log_event "SKIPPED" "Skip marker detected - user previously selected skip option"
  echo "âš¡ [enforce-spec-folder] Skip marker detected - proceeding without spec folder" >&2
  END_TIME=$(date +%s%N)
  DURATION=$(((END_TIME - START_TIME)/1000000))
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms (skipped)" >> "$PERF_LOG"
  exit 0
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SEARCH FOR RELATED SPECS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RELATED_SPECS=$(find_related_specs "$PROMPT")

if [ -n "$RELATED_SPECS" ]; then
  echo "ğŸ“‹ [enforce-spec-folder] Found related specs, suggesting reuse..." >&2
  print_section "RELATED SPECS FOUND"
  print_detail "Found existing specs that may be related to your request:"
  print_line

  while IFS=':' read -r field1 field2 field3 field4; do
    # Parse format based on type (4th field)
    # Parent format: path:active_child:PARENT_ACTIVE or path::PARENT_INACTIVE
    # Child format: priority:path:status:CHILD

    local path=""
    local type="${field4:-$field3}"  # Type is 4th field for children, 3rd for parents

    # Determine path based on format
    if [[ "$type" == PARENT_* ]]; then
      # Parent format: field1=path, field2=active_child, field3=type
      path="$field1"
      local active_child="$field2"
      local name=$(basename "$path")

      if [[ "$type" == "PARENT_ACTIVE" ]]; then
        print_detail "  ğŸ¢ $name (PARENT FOLDER - active work ongoing)"
        print_detail "    â†’ Active child: $active_child"
        print_detail "    â†’ Suggested: Continue in new sub-folder"
        print_detail "    â†’ Path: $path"
      else
        print_detail "  ğŸ¢ $name (PARENT FOLDER - inactive)"
        print_detail "    â†’ No active work currently"
        print_detail "    â†’ Suggested: Resume or create new sub-folder"
        print_detail "    â†’ Path: $path"
      fi
      print_line
    elif [[ "$type" == "CHILD" ]]; then
      # Child format: field1=priority, field2=path, field3=status, field4=CHILD
      path="$field2"
      local status="$field3"
      local name=$(basename "$path")
      local status_label=""

      case "$status" in
        active) status_label="âœ“ ACTIVE - recommended for updates" ;;
        draft) status_label="â— DRAFT - can be started" ;;
        paused) status_label="â¸  PAUSED - can be resumed" ;;
        complete) status_label="âœ“ COMPLETE - reopening discouraged" ;;
        archived) status_label="ğŸ“¦ ARCHIVED - do not reuse" ;;
        *) status_label="status: $status" ;;
      esac

      print_detail "  â€¢ $name"
      print_detail "    Status: $status_label"
      print_detail "    Path: $path"
      print_line
    fi
  done <<< "$RELATED_SPECS"

  print_section "RECOMMENDATION"
  print_detail "Consider updating one of the related specs above instead of creating a new one."
  print_detail "For parent folders, system will create new numbered sub-folder automatically."
  print_detail "Guidelines: .claude/knowledge/conversation_documentation.md Section 7"
  print_detail ""
  print_detail "AI should ask user:"
  print_detail "  A) Update existing spec (if work is related)"
  print_detail "  B) Create new spec (if work is distinct)"
  print_line
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SPEC_FOLDER=""
SPEC_FOLDER_NAME=""
NEEDS_CONFIRMATION=false

if [ "$CHECK_SPEC_FOLDER" != "false" ]; then
  # Sync global marker to local markers before folder detection
  sync_marker_to_parent 2>/dev/null || true

  SPEC_FOLDER=$(find_latest_spec_folder)

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # SKIP VALIDATION IF MID-CONVERSATION (SUBSTANTIAL CONTENT EXISTS)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Only prompt at start when spec folder is empty or has minimal content.
  # Once real work has started (files added or substantial edits made),
  # skip validation to avoid repeated prompts during conversation.

  if [ -n "$SPEC_FOLDER" ] && has_substantial_content "$SPEC_FOLDER"; then
    SPEC_FOLDER_NAME=$(basename "$SPEC_FOLDER")
    log_event "ALLOWED" "Mid-conversation detected in $SPEC_FOLDER_NAME (substantial content exists, checking for memory files)"
    echo "âœ… [enforce-spec-folder] Mid-conversation: ${SPEC_FOLDER_NAME} (checking memory files)" >&2

    # Check for marker staleness (optional warning, doesn't block)
    if [ -f "$SPEC_MARKER" ]; then
      active_marker_path=$(cat "$SPEC_MARKER" 2>/dev/null | tr -d '\n')
      if [ -n "$active_marker_path" ]; then
        # Extract keywords from prompt
        prompt_keywords=$(echo "$PROMPT_LOWER" | tr ' ' '\n' | grep -E '^[a-z]{3,}$' | sort -u)

        if check_marker_staleness "$prompt_keywords" "$active_marker_path"; then
          # Marker appears stale but don't block - just warn
          echo "âš ï¸  [enforce-spec-folder] Marker may be stale: working in $SPEC_FOLDER_NAME but prompt seems unrelated" >&2
          log_event "MARKER_STALE" "Potential stale marker: $active_marker_path (prompt keywords don't match)"
        fi
      fi
    fi

    # Check for memory files and present selection prompt if available
    if present_memory_selection_prompt "$SPEC_FOLDER"; then
      log_event "MEMORY_PROMPT" "Presented memory file selection for $SPEC_FOLDER_NAME"
      echo "ğŸ§  [enforce-spec-folder] Memory files found, presented selection prompt" >&2
    else
      echo "âœ… [enforce-spec-folder] No memory files found, proceeding without context" >&2
    fi

    END_TIME=$(date +%s%N)
    DURATION=$(((END_TIME - START_TIME)/1000000))
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms (mid-conversation)" >> "$PERF_LOG"
    exit 0
  fi

  # Empty or minimal content â†’ Start of conversation, run validation
  if [ -z "$SPEC_FOLDER" ]; then
    if [ "$ENFORCEMENT_MODE" = "warning-only" ]; then
      handle_warning "No spec folders detected in specs/."
    else
      handle_confirmation "No spec folder detected" ""
      NEEDS_CONFIRMATION=true
    fi
  else
    SPEC_FOLDER_NAME=$(basename "$SPEC_FOLDER")
  fi
fi

if [ "$NEEDS_CONFIRMATION" = false ] && [ -n "$SPEC_FOLDER" ] && [ "$CHECK_TEMPLATES" != "false" ]; then
  if ! validate_templates "$SPEC_FOLDER"; then
    local joined_errors="$(printf '%s; ' "${VALIDATION_ERRORS[@]}")"
    if [ "$ENFORCEMENT_MODE" = "warning-only" ]; then
      handle_warning "$joined_errors"
    else
      handle_confirmation "$joined_errors" "$SPEC_FOLDER_NAME"
      NEEDS_CONFIRMATION=true
    fi
  fi
fi

# If confirmation was needed, exit here (don't show validation success)
if [ "$NEEDS_CONFIRMATION" = true ]; then
  END_TIME=$(date +%s%N)
  DURATION=$(((END_TIME - START_TIME)/1000000))
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms (confirmation-needed)" >> "$PERF_LOG"
  exit 0
fi

log_event "ALLOWED" "Spec folder validated: ${SPEC_FOLDER_NAME:-n/a}"
echo "âœ… [enforce-spec-folder] Spec folder validated: ${SPEC_FOLDER_NAME:-n/a}" >&2
END_TIME=$(date +%s%N)
DURATION=$(((END_TIME - START_TIME)/1000000))
echo "[$(date '+%Y-%m-%d %H:%M:%S')] enforce-spec-folder.sh ${DURATION}ms (${SPEC_FOLDER_NAME:-no-spec})" >> "$PERF_LOG"
exit 0
